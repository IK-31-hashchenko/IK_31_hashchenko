1. У папці з лабораторною створюю папки my_app та tests, в які копіюю відповідні файли з репозиторію,ознайомлююсь з їх вмістом. Пееглядаю файл requirements.txt. Він містить залежності додатку.
2. Виконую команди для перевірки працездатності проекту:
   - `pipenv --python 3.7`
   - `pipenv install -r requirements.txt`
   - `pipenv run python app.py`
3. Під час запуску сервера виникає помилка: `redis.exceptions.ConnectionError: Error -2 connecting to redis:6379. Name or service not known.` Для вирішення проблеми встановлюю redis server за допомогою команд:
   -  `sudo apt-get install redis-server`  
4. Також роблю зміни у etc/hosts, для того, щоб перенаправити запити на адресу 127.0.0.1 redis.
5. Після цього запускаю сервер і переконуюсь, що програма працює.
6. Тут буде скріншот 6.
7. У другому вікні терміналу запускаю тестування, за допомогою команди:
   -  'pipenv run pytest test_app.py --url http://localhost:5000'
8. Тут буде скріншот 7.
9. Один з тестів виявив помилку. Для того, щоб всі тести виконались успішно, я створюю підпапку logs у папці my_app. 
10. Тут буде скріншот 10.
11. Перевіряю, чи відкриваються в браузері сторінки /hits та /logs.
12. Тут буде скріншот 8.
13. Тут буде скріншот 9.
14. Видаляю файли і папки, що були створені після тестового запуску.
15. Створюю два Dockerfile та Makefile, відповідно до зразка.
16. Ознайомлююсь з вмістом Dockerfile та Makefile, їх директивами.
    - STATES - змінна, що містить назву тегу.
    - REPO - змінна, що містить назву репозиторію.
    - .PHONY - директива, що підставляє значення STATES у $(STATES).
    - $(STATES) - директива, призначена для білду Docker Image.
    - run - для запуску сайту та redis.
    - test-app - для запуску тестів.
    - docker-prune - директива для очищення ресурсів Docker.
17. Створюю Docker імеджі для додатку та тестів:
    - `make .PHONY`
18. У двох вікнах терміналу запускаю додаток і тестую його за допомогою команд:
    - `make run`
    - `make test-app`
19. Тут будуть скріншоти з результатами тестування.
20. Перевіряю роботу сторінок сайту.
21. Тут будуть скріншоти зі сторінками сайту.
22. Зупиняю проект, та очищую ресурси Docker за допомогою команди:
    - `make docker-prune`
23. Створюю директиви у Makefile, для того, щоб зробити push до мого Docker репозиторію.
24. [Docker Hub repository](https://hub.docker.com/repository/docker/hashchenko/lab_5)
25. За допомогою Makefile автоматизую процес видалення імеджів.
26. Тут буде скріншот з пустими імеджами.
## Docker compose ##
1. Згідно зразка, створюю файл docker-compose.yml.В ньому створюються дві мережі: public і secret. Secret потрібна для комунікації внутрішніх ресурсів, а public для звичайних користувачів.
2. Перевіряю роботу docker-compose та запускаю його.
    - `docker-compose version`
    - `docker-compose -p lab_5 up`
3. Тут буде скріншот коду.
4. Перевіряю, як працює сайт. Для цього заходжу на адресу 127.0.0.1
5. Тут будуть скріншоти сайту.
6. Перевіряю наявність імейджів.Імейджі мають теги compose-app і compose-tests. Змінюю репозиторій на свій, та перезапускаю docker-compose, перед тим очистивши імейджі за допомогою директиви Makefile.
7. Тут будуть скріншоти з порівнянням імейджів.
8. Очищую ресурси та роблю push до Docker репозиторію.
## Завдання ##
1. На мою думку, працювати з docker-compose значно зручніше, ніж з Makefile, адже docker-compose може запускати всю програму лише однією командою, що значно полегшує робту з великими проектами і економить час.
2. 


